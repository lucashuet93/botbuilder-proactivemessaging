# Proactive Bot - TypeScript Samples

The Proactive Bot covers the following use cases:

[**Basic Implementation**](#basicimplementation)
- Send a proactive message within the same conversation.

[**Broadcasting Implementation**](#broadcastingimplementation)
- Broadcast a message to all live conversations from with-in chat.
- Broadcast a message to all live conversations from external endpoint.

<a name="basicimplementation"></a>

## Proactive Bot - Basic Implementation

The basic implementation covers dealing with conversation references and sending delayed messages to the same conversation. 

A good use case for that is when user requested for some info or action, but extracting or executing it will take some time. So you put a request into some queue with the conversation reference data, and when response is ready you just restore the conversation.

### Prerequisites

1. This sample begins from creating a fresh new **typescript**-based **echo-bot**. For more details on how to make original setup checks this docs: [Create a bot with the Bot Framework SDK for JavaScript](https://docs.microsoft.com/en-us/azure/bot-service/javascript/bot-builder-javascript-quickstart?view=azure-bot-service-4.0).

2. To deploy the bot to the Azure Bot Service (ABS) follow the following instructions: [Deploy your bot](https://docs.microsoft.com/en-us/azure/bot-service/bot-builder-deploy-az-cli?view=azure-bot-service-4.0).

Important notes:
- Ensure you update your `<botname>.bot` file with the configuration data that you got from the ABS-generated bot. There are various strategies on how to manage encrypting, decrypting and updating the secret key. Just don't store a decrypted file in a public repository, or a repository that may eventually become public.
- Update the `botFilePath` variable in Application Settings sections on the Azure Portal to reference to your `<botname>.bot` file, if the file name differs from the one generated by the ABS.
- If you are using a CI/CD pipeline (e.g., Azure DevOps Pipeline), ensure you added a TypeScript compiling step into your pipeline. In case you are using Azure DevOps, you can add the [Compile Typescript](https://marketplace.visualstudio.com/items?itemName=bool.compile-type-script) task component from the marketplace.
- Update the `web.config` file to refer to your starting point (e.g. `app.js` in the root folder, or `index.js` in the `lib` folder).

### Store Conversation Reference
To continue the conversation in a distant moment in future, we have to extract and store somewhere a reference to the current conversation.
- To extract the reference we use the static function: `TurnContext.getConversationReference`. 
- Conversation reference is just a JSON-object (the `ConversationReference` class) of the following structure:

```js
{
    "activityId": "a63c3a30-405a-11e9-91b4-7126f993d60c",
    "user": {
        "id": "3efd258a-7f19-4e79-8356-16500324b4d5",
        "name": "User"
    },
    "bot": {
        "id": "3",
        "name": "Bot",
        "role": "bot"
    },
    "conversation": {
        "id": "a6350e40-405a-11e9-9756-f387f04916fa|livechat"
    },
    "channelId": "emulator",
    "serviceUrl": "http://localhost:60833",
}
```
- To temporary save the reference we create a `ConversationState` object based on a `MemoryStorage` object.

1. Create a new class [`InMemoryConversationStorage`](./proactive-bot/src/services/InMemoryConversationStorage.ts) (e.g., in the `/services/` subfolder), that will encapsulate calls to the methods/objects mentioned above. Implement two main methods defined in the [`IConversationStorageService`](./proactive-bot/src/services/IConversationStorageService.ts) interface (optionally, you can also update the state):

*Restore or create a reference to the conversation*
```js
    public async restoreReference(context: TurnContext): Promise< Partial<ConversationReference> > {
        // try extract stored reference
        let reference = await this.conversationReferenceStorage.get(context);
        const activity = context.activity;
        // else create a new reference from the context
        if (reference === null || reference === undefined) {
            reference = TurnContext.getConversationReference(activity);
        }
        return reference;
    }
```

*Store a reference to the conversation*
```js
    public async storeReference(context: TurnContext): Promise< Partial<ConversationReference> > {
        const reference = await this.restoreReference(context);
        await this.conversationReferenceStorage.set(context, reference);
        return reference;
    }
```

2. Create a new conversation storage object and pass it to the bot constructor (in the `index.ts`):
```js
// Create the main dialog.
const conversationStorageService = new InMemoryConversationStorage();
const proactiveBot = new ProactiveBot(conversationStorageService);
```

And store the reference to storage in a bot property:

```js
constructor(private conversationStorageService: IConversationStorageService) {
}
```

3. Finally, store the reference, once the dialog is activated:
```js
        else if (context.activity.type === ActivityTypes.ConversationUpdate) {
            ...
            if (memberAdded && notBot) {
                await this.sendWelcomeMessage(context);
                // Extract the reference from the context and store in inside the storage service
                await this.conversationStorageService.storeReference(context);
            }
        }
```

### Send proactive message

Next, add a method for proactive messaging inside your bot implementation (the `bot.ts` file). 

1. If you attemp to just delay sending a message, your code will fail doing it, as by that moment it will lose the context of the conversation:
```js
    private async sendDelayedMessage(context: TurnContext, msg: string, delay: number) {
        const echoMessage = `**Delayed**: *${msg}*`;
        const notifyMessage = `*Delayed message will come in ${delay / 1000} seconds.`;
        await context.sendActivity(notifyMessage);
        setTimeout(async () => {
            // This code fails to execute.
            await context.sendActivity(echoMessage);
        }, delay);
    }
```

2. Instead, we will restore the reference for active conversation and pass it to a new endpoint:
```js
    private async sendDelayedMessage(context: TurnContext, msg: string, delay: number) {
        const echoMessage = `**Delayed**: *${msg}*`;
        const notifyMessage = `*Delayed message will come in ~${delay / 1000} seconds.*`;
        await context.sendActivity(notifyMessage);
        // Restore conversation reference
        const reference = await this.conversationStorageService.restoreReference(context);
        setTimeout(async () => {
            await this.broadcastService.broadcast([reference], echoMessage);
        }, delay);
    }
```

Here we are calling the `broadcast` method of some new object `broadcastService` that we didn't add to the project so far. So let's fix it.

**Important note**
- To trigger the `sendDelayedMessage` method we also updated the `onTurn` method to parse keywords from the user input.

```js
        ...
        if (context.activity.type === ActivityTypes.Message) {
            const msg = context.activity.text;
            const keywordsRegExp = /(^delay|^postpone|^wait)/i;
            const match = msg.match(keywordsRegExp);

            if (match !== null) {
                if (match[0] === "delay" || match[0] === "postpone" || match[0] === "wait") {
                    const realmsg = msg.substring(match[0].length + 1).trim();
                    await this.sendDelayedMessage(context, realmsg, 5000);
                }
            } else {
                await this.sendEchoMessage(context, context.activity.text);
            }
        }
```

### Add Broadcasting Service

Now let's implement the broadcasting service mentioned above. It will send the message to specified endpoint, also passing the reference to conversation that should be restored.

1. Add a new broadcasting service to the project, that implements a simple broadcasting interface ([`IBroadcastService`](./proactive-bot/src/services/IBroadcastService.ts)):

```js
export interface IBroadcastService {
    broadcast(references: Array< Partial<ConversationReference> >, message: string);
}
```

Our [`LocalBroadcastService`](./proactive-bot/src/services/LocalBroadcastService.ts) is pretty simple -- it is just a wrapper around sending an http request using `fetch` (isomorphic-fetch):

```js
export class LocalBroadcastService implements IBroadcastService {
    constructor(private localEndpoint) {
    }

    public async broadcast(references: Array< Partial<ConversationReference> >, message: string) {
        const broadcastMessage = {
            message,
            references,
        };

        await fetch(this.localEndpoint, {
            body: JSON.stringify(broadcastMessage),
            headers: { "Content-Type": "application/json" },
            method: "POST",
        });
    }
}
```

2. Add the reference to broadcasting service to the bot (`index.ts`):

```js
const conversationStorageService = new InMemoryConversationStorage();
const localBroadcastEndpoint = "http://localhost:3978/api/broadcast";
const broadcastService = new LocalBroadcastService(localBroadcastEndpoint);
const proactiveBot = new ProactiveBot(conversationStorageService, broadcastService);
```

### Add Broadcasting Endpoint

Next, our bot should be able to listen to messages on that endpoint.

1. Add the broadcasting endpoint for the bot (`index.ts`):

```js
// Listen for broadcasting requests
server.post("/api/broadcast", async (req, res) => {
    const broadcastMessage = req.body;
    if (broadcastMessage !== null && broadcastMessage !== undefined) {
        const references = broadcastMessage.references;
        const message = broadcastMessage.message;
        const notifyMessage = `*Broadcasting message is comming...*`;
        await references.forEach(async (reference) => {
            // Ensure we are not calling localhost references when we are deployed to the cloud
            const localUrl = reference.serviceUrl.includes("localhost");
            const localEnv = BOT_CONFIGURATION === DEV_ENVIRONMENT;
            const matchEnv = (localEnv) || (!localEnv && !localUrl);
            if (matchEnv) {
                try {
                    // Try restore conversation
                    await adapter.continueConversation(reference, async (turnContext) => {
                        await turnContext.sendActivity(notifyMessage);
                        await turnContext.sendActivity(message);
                    });
                } catch (err) {
                    // Catch unresponsive references
                }
            }
        });
        res.send(200);
    } else {
        // No body found
        res.send(204);
    }
});
```

**Important notes**:
- The endpoint accepts an array of references for future scalability (e.g., broadcast to multiple conversations).
- We are checking if the current environment is development or production (e.g., to avoid sending messages to the localhost while deployed).
- We are catching attempts to restore conversation as not all the references might be active.
- To parse the body of the request, add the body parsing plugin to restify:
```js 
server.use(restify.plugins.bodyParser());
```

### Deploy The Bot to The Cloud

Now let's add some fixes to allow out bot working from the cloud. 

1. Add a reference to the bot deplyment url to your `.env` file and to the application settings on the Azure Portal.
```
botAzureServiceURL="https://<YOUR_BOT_NAME>.azurewebsites.net"
```

2. Update the reference to the broadcasting endpoint in the `index.ts` file:
```js
const localURL = "http://localhost:3978";
const botServiceURL = (BOT_CONFIGURATION === DEV_ENVIRONMENT) ? localURL : process.env.botAzureServiceURL;

// Create the main dialog.
...
const broadcastEndpoint = `${botServiceURL}/api/broadcast`;
const broadcastService = new LocalBroadcastService(broadcastEndpoint);
const proactiveBot = new ProactiveBot(conversationStorageService, broadcastService);
```

---
### Proactive Bot - Basic Implementation Summary

So far we reached the point when we can type to the bot something like "delay: Hello world" and it will react to that message with a 5-sec delay by sending back some message.

To do that, we extract the conversation reference and send it to the broadcasting endpoint. At the endpoint we restore the conversation and send the message to the user.

---
<a name="broadcastingimplementation"></a>

## Proactive Bot - Broadcasting Implementation

Our next step in the journey of building a proactive bot is to allow the massive broadcasting for multiple users. 

For that we have to store somewhere (in the cloud) references to all the conversations. Once you extract the list of references, you can send messages to all active users.

### Store All The References to The Cloud

In this sample we use a CosmosDB database to store conversation references and Azure Functions to communicate with database.  You can also interact with CosmosDB right from the bot (e.g., bu using [JavaScript SDK for CosmosDB](https://www.npmjs.com/package/@azure/cosmos)).

Use might also decide to use any other services of you choice for these purposes. We just recommend to keep some abstraction layer.

1. Create an instance of the CosmosDB database through the Azure Portal. Use `SQL Core` as API. Create a new database (e.g., `ConversationsDB`) and a new collection (e.g., `ConversationReferences`, use `channelId` as partition key). 

2. Create an instance of the Azure Function App. Configure development and deployment if required. Note that you can now [use TypeScript templates to write your functions](https://azure.microsoft.com/en-us/blog/improving-the-typescript-support-in-azure-functions/), but you still might need to add typescript compiling step in case you use the Azure DevOps Pipeline to deploy.

3. Create a new function inside your Azure Function App as http-trigger (e.g. [`storeConversationReference`](./proactive-bot-fn/storeConversationReference)). 

**Important note**:
- To use the binging with CosmosDB in Azure Functions you need the `Microsoft.Azure.WebJobs.Extensions.CosmosDB` extension installed for you app. The best way to get it is to add any new function to the app inside the Azure Portal and then to add an integration with CosmosDB through the interface.

4. In the [`function.json`](./proactive-bot-fn/storeConversationReference/function.json) file (or manually through the Azure Portal) add the out-binding to connect with your CosmosDB database:

```js
    {
      "type": "cosmosDB",
      "name": "inputConversationReference",
      "databaseName": "ConversationsDB",
      "collectionName": "ConversationReferences",
      "createIfNotExists": false,
      "connectionStringSetting": "<YOUR_COSMOSDB_ACCOUNT_NAME>_DOCUMENTDB",
      "direction": "out",
      "partitionKey": "clientId"
    }
```

The connection string usually is generated one you choose you CosmosDB account, update the database and collection names if you used other names while setting up you CosmosDB account.

5. Update the default function code (in the [`index.ts`](./proactive-bot-fn/storeConversationReference/index.ts) file) to store the reference from the request to the `inputConversationReference` variable from the binding `context`:

```js
const httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {
    context.log("Storing conversation reference.");

    const reference = (req.query.reference || (req.body && req.body.reference));

    if (reference) {
        context.res = {
            status: 200
        };
        context.bindings.inputConversationReference = reference;
    }
    else {
        context.res = {
            status: 400,
            body: "Please pass a reference on the query string or in the request body"
        };
    }
    context.done();
};
```

4. Deploy the function to the Azure Function App (or manually update the code on the portal).

5. Add a new class [`CloudConversationStorageService`](./proactive-bot/src/services/CloudConversationStorageService.ts) extending the [`InMemoryConversationStorage`](./proactive-bot/src/services/InMemoryConversationStorage.ts) class. Its purpose so far is to pass the stored reference to the endpoint we just deployed to the cloud. That endpoint function will do the job to store reference in the CosmosDB.

```js
export class CloudConversationStorageService extends InMemoryConversationStorage {
    public constructor(private storageEndpoint: string) {
        super();
    }

    public async storeReference(context: TurnContext): Promise<ConversationReference> {
        const reference = await super.storeReference(context);

        if (reference !== null && reference !== undefined) {
            await fetch(this.storageEndpoint, {
                body: JSON.stringify({ reference }),
                headers: { "Content-Type": "application/json" },
                method: "POST",
            });
        }

        return reference;
    }
}
```

Note that we are now passing a `cloudStoreEndpoint` url that should be triggered. It is the URL to our Azure Function defined above.

6. In the `index.ts` substitute `InMemoryConversationStorage` usage with the service we just created:

```js
// Create the main dialog.
// Use cloud storate to store conversation references
const cloudStoreEndpoint = process.env.cloudStoreEndpoint;
const conversationStorageService = new CloudConversationStorageService(cloudStoreEndpoint);
// const conversationStorageService = new InMemoryConversationStorage();
const broadcastEndpoint = `${botServiceURL}/api/broadcast`;
const broadcastService = new LocalBroadcastService(broadcastEndpoint);
const proactiveBot = new ProactiveBot(conversationStorageService, broadcastService);
```

7. Add the `cloudStoreEndpoint` to your `.env` file and to your bot's application settings on the Azure Portal with the value of the function url. For example:

```js
cloudStoreEndpoint="https://<AZURE_FUNCTION_APP_NAME>.azurewebsites.net/api/storeConversationReference?code=<FUNCTION_ACCESS_KEY>"
```

8. Test if creating a new conversation results in storing conversation reference in the CosmosDB database.

### Broadcast Messages through The Cloud

Our next goal is to extract the conversation references from CosmosDB and send some messages to these references.

1. Add a new function (e.g., `getConversationReferences`) to your Azure Function app that will extract the list of references and send it back as response.

2. Updates function's bindings file to add the in-binding to connect with your CosmosDB account:

```js
    {
      "type": "cosmosDB",
      "name": "conversationReferences",
      "databaseName": "ConversationsDB",
      "collectionName": "ConversationReferences",
      "connectionStringSetting": "<YOUR_COSMOSDB_ACCOUNT_NAME>_DOCUMENTDB",
      "direction": "in",
      "sqlQuery": "SELECT * FROM d"
    }   
```

Here are are also defining the SQL-query to extract the data. You can modify it based on your preference, or furtner extend the function to exctract only specific reference, filter-out the origin reference and so on.

3. Update the function's implementation to pass the `conversationReferences` content as trigger response:

```js
const httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {
    context.log('Collecting broadcasting list.');

    const originReference = (req.query.reference || (req.body && req.body.reference));
    const conversations = context.bindings.conversationReferences;

    if (conversations.length > 0) {
        context.res = {
            status: 200,
            body: JSON.stringify({
                references: conversations,
                origin: originReference,
            }),
        }
    } else {
        context.res = {
            status: 404,
            body: "No active references found."
        };
    }
    
    context.done();
};
```

4. Deploy the function to the cloud and add its url to your bot's `.env` file and cloud-bot application settings:

```js
cloudRestoreEndpoint="https://<AZURE_FUNCTION_APP_NAME>.azurewebsites.net/api/getConversationReferences?code=<FUNCTION_ACCESS_KEY>"
```

5. Add a new command to recognize by the bot to make a broadcasting. In the `bot.ts` file edit the `onTurn` method to filter the `broadcast` command from user input and call a corresponding method to process that activity:

```js
            const keywordsRegExp = /(^delay|^postpone|^wait|^broadcast|^helloworld)/i;
            const match = msg.match(keywordsRegExp);

            if (match !== null) {
                const realmsg = msg.substring(match[0].length + 1).trim();
                if (match[0] === "delay" || match[0] === "postpone" || match[0] === "wait") {
                    await this.sendDelayedMessage(context, realmsg, 5000);
                } else if (match[0] === "broadcast" || match[0] === "helloworld") {
                    await this.sendBroadcastMessage(context, realmsg);
                }
            }
```

Also add a new method to the bot:

```js
    private async sendBroadcastMessage(context: TurnContext, msg: string) {
        const echoMessage = `**Broadcasting**: *${msg}*`;
        const notifyMessage = `*Broadcasting to everyone in the chat!*`;
        await context.sendActivity(notifyMessage);
        // Restore conversation reference
        const references = await this.conversationStorageService.restoreAllReferences(context);
        await this.broadcastService.broadcast(references, echoMessage);
    }
```

The `restoreAllReferences` method is not implemented yet, but we will fix it in a minute.

6. Add a new `IBroadcastStorageService` interface extending the `IConversationStorageService` with a new `getAllReferences` method:

```js
export interface IBroadcastStorageService extends IConversationStorageService {
    restoreAllReferences(context: TurnContext): Promise< Array< Partial< ConversationReference > > >;
}
```

Update you bot constructor to expect this new interface instead of the `IConversationStorageService`:

```js
    constructor(private conversationStorageService: IBroadcastStorageService,
                private broadcastService: IBroadcastService) {
    }
```

Update the `CloudConversationStorageService` class to implement this new interface, add a new `restoreEndpoint` argument to its constructor:

```js
export class CloudConversationStorageService extends InMemoryConversationStorage implements IBroadcastStorageService {
    public constructor(private storageEndpoint: string, private restoreEndpoint: string) {
        super();
    }
    ...
}
```

And the implementation for the `getAllReferences` method:

```js
    public async restoreAllReferences(context: TurnContext): Promise< Array< Partial< ConversationReference > > > {
        const originReference = await this.restoreReference(context);

        const response = await fetch(this.restoreEndpoint, {
            body: JSON.stringify({ reference: originReference }),
            headers: { "Content-Type": "application/json" },
            method: "POST",
        });

        if (response.status === 200) {
            const body = await response.json();
            return body.references;
        } else {
            return [originReference];
        }
    }
```

7. Test/deploy the bot. Now you should be able to type something like "broadcast: hey!" and all connected users should receive that notification.

### Broadcast Messages from an External Endpoint

Our final exercise is to initiate broadcasting from an external endpoint. To implement it we will add a new Azure Function for broadcasting and a Azure Logic App to trigger the project.

1. Add a new `broadcast` function to the Azure Function app. It does not require binding with CosmosDB.

```js
const httpTrigger: AzureFunction = async function (context: Context, req: HttpRequest): Promise<void> {
    context.log('Broadcasting to everyone');

    const message = (req.query.message || (req.body && req.body.message));
    
    const restoreReferencesEndpoint = process.env.cloudRestoreEndpoint;
    const broadcastingEndpoint = process.env.broadcastEndpoint;

    const response = await fetch(restoreReferencesEndpoint, {
        method: 'POST',
        body: JSON.stringify({}),
        headers: { 'Content-Type': 'application/json' }
    });

    if (response.status === 200) {
        const body = await response.json();
        const references = body.references;

        await fetch(broadcastingEndpoint, {
            method: 'POST',
            body: JSON.stringify({
                message,
                references,
            }),
            headers: { 'Content-Type': 'application/json' }
        });
        context.res = {
            status: 202,
            body: "Broadcasting complete.",
        };

    } else {
        context.res = {
            status: 404,
            body: "No conversation reference found for broadcasting.",
        };
    }
    context.done();
};
```

Note that we are using two parameters -- `cloudRestoreEndpoint` and `broadcastEndpoint` -- from the environment.

2. Add the url of your bot's broadcasting endpoint and the url for the `getConversationReferences` function to the application settings for your Azure Function app:
```js
broadcastEndpoint --> "https://<YOUR_BOT_NAME>.azurewebsites.net/api/broadcast"
cloudRestoreEndpoint --> "https://<AZURE_FUNCTION_APP_NAME>.azurewebsites.net/api/getConversationReferences?code=<FUNCTION_ACCESS_KEY>"
```

3. Use the postman (or similar) service or Azure Portal to trigger or test your broadcasting function passing a message as body content:

```js
{ "message": "hello" }
```

4. Finally to finish this sample let's add a Logic App that will trigger the broadcast function on timer events. Through the Azure Portal create a new Logic App. From the templates choose the "Reccurence" template.

Setup the timing (e.g., set it trigger every 5 minutes).

Add a new step, select Azure Function, then you Azure Function app name, then `broadcast`. Define the massage that should be broadcasted every five minutes like:

```js
{ "message": "Hey! Just wanna everyone know, that another 5 minutes passed in this segment of the universe. Wow!" }
```

Test it. And don't forget to disable the trigger, if you are not sure on sending such events every 5 minutes to every user.

:)






